import 'package:get/get.dart';
import 'package:drift/drift.dart' as drift;
import 'package:tkt_pos/data/local/app_database.dart';

class InventoryController extends GetxController {
  final AppDatabase db = AppDatabase();

  final Rx<DateTime> selectedDate = Rx<DateTime>(DateTime.now());
  final RxList<Driver> drivers = <Driver>[].obs;
  final Rx<int?> selectedDriverId = Rx<int?>(null);
  final RxList<DbTransaction> transactions = <DbTransaction>[].obs; // legacy single-driver view
  final RxMap<int, List<DbTransaction>> transactionsByDriver = <int, List<DbTransaction>>{}.obs;
  final RxString searchQuery = ''.obs;
  final RxBool isLoading = false.obs;

  @override
  void onInit() {
    super.onInit();
    // Load all drivers initially for sectioned UI
    loadAllDrivers();
  }

  Future<void> loadDriversForDate(DateTime date) async {
    isLoading.value = true;
    try {
      final start = DateTime(date.year, date.month, date.day);
      final end = start.add(const Duration(days: 1));
      final query = (db.select(db.drivers)
            ..where(
              (d) => d.date.isBiggerOrEqualValue(start) & d.date.isSmallerThanValue(end),
            )
            ..orderBy([(d) => drift.OrderingTerm.asc(d.name)]));
      final list = await query.get();
      drivers.assignAll(list);
      // Reset selection if current selection not in list
      if (selectedDriverId.value == null ||
          !list.any((e) => e.id == selectedDriverId.value)) {
        selectedDriverId.value = list.isNotEmpty ? list.first.id : null;
      }
      if (selectedDriverId.value != null) {
        await loadTransactionsByDriver(selectedDriverId.value!);
      } else {
        transactions.clear();
      }
    } finally {
      isLoading.value = false;
    }
  }

  Future<void> loadAllDrivers() async {
    isLoading.value = true;
    try {
      final list = await (db.select(db.drivers)
            ..orderBy([
              (d) => drift.OrderingTerm.desc(d.date),
              (d) => drift.OrderingTerm.asc(d.name),
            ]))
          .get();
      drivers.assignAll(list);
      // Load transactions for each driver
      for (final d in list) {
        await loadTransactionsByDriverToMap(d.id);
      }
    } finally {
      isLoading.value = false;
    }
  }

  Future<void> setDate(DateTime date) async {
    selectedDate.value = date;
    await loadDriversForDate(date);
  }

  Future<void> setDriver(int? driverId) async {
    selectedDriverId.value = driverId;
    if (driverId != null) {
      await loadTransactionsByDriver(driverId);
    } else {
      transactions.clear();
    }
  }

  Future<void> loadTransactionsByDriver(int driverId) async {
    isLoading.value = true;
    try {
      final list = await db.getTransactionsByDriver(driverId);
      transactions.assignAll(list);
    } finally {
      isLoading.value = false;
    }
  }

  Future<void> loadTransactionsByDriverToMap(int driverId) async {
    final list = await db.getTransactionsByDriver(driverId);
    transactionsByDriver[driverId] = list;
    // trigger RxMap update
    transactionsByDriver.refresh();
  }

  void setSearch(String q) {
    searchQuery.value = q;
  }

  List<DbTransaction> get filteredTransactions {
    final q = searchQuery.value.trim().toLowerCase();
    if (q.isEmpty) return transactions;
    return transactions.where((t) {
      final fields = <String?>[
        t.customerName,
        t.phone,
        t.parcelType,
        t.number,
        t.paymentStatus,
        t.cashAdvance.toString(),
        t.charges.toString(),
      ];
      return fields.any((f) => (f ?? '').toLowerCase().contains(q));
    }).toList(growable: false);
  }

  List<DbTransaction> filteredTransactionsForDriver(int driverId) {
    final q = searchQuery.value.trim().toLowerCase();
    final source = transactionsByDriver[driverId] ?? const <DbTransaction>[];
    if (q.isEmpty) return source;
    return source.where((t) {
      final fields = <String?>[
        t.customerName,
        t.phone,
        t.parcelType,
        t.number,
        t.paymentStatus,
        t.cashAdvance.toString(),
        t.charges.toString(),
      ];
      return fields.any((f) => (f ?? '').toLowerCase().contains(q));
    }).toList(growable: false);
  }

  Future<int> addDriver({required DateTime date, required String name}) async {
    final id = await db.insertDriver(DriversCompanion.insert(date: date, name: name));
    // reload list
    await loadAllDrivers();
    return id;
  }

  Future<void> updateDriver({required int id, required DateTime date, required String name}) async {
    await db.update(db.drivers).replace(
          Driver(id: id, date: date, name: name),
        );
    await loadAllDrivers();
  }

  Future<void> deleteDriver(int id) async {
    await db.transaction(() async {
      // Remove child transactions first to avoid foreign key constraint errors
      await (db.delete(db.transactions)..where((t) => t.driverId.equals(id))).go();
      await db.deleteDriverById(id);
    });
    // Refresh state
    await loadAllDrivers();
  }

  Future<void> addTransaction({
    required int driverId,
    String? customerName,
    required String phone,
    required String parcelType,
    required String number,
    required double charges,
    required String paymentStatus,
    double? cashAdvance,
    required bool pickedUp,
    String? comment,
  }) async {
    await db.insertTransaction(
      TransactionsCompanion.insert(
        customerName: drift.Value(customerName),
        phone: phone,
        parcelType: parcelType,
        number: number,
        charges: drift.Value(charges),
        paymentStatus: paymentStatus,
        cashAdvance: cashAdvance == null
            ? const drift.Value.absent()
            : drift.Value(cashAdvance),
        pickedUp: drift.Value(pickedUp),
        comment: drift.Value(comment),
        driverId: driverId,
      ),
    );
    await loadTransactionsByDriverToMap(driverId);
  }

  Future<void> updateTransaction(TransactionsCompanion companion) async {
    await db.update(db.transactions).replace(companion);
    final driverId = companion.driverId.present ? companion.driverId.value : null;
    if (driverId != null) {
      await loadTransactionsByDriverToMap(driverId);
    } else if (selectedDriverId.value != null) {
      await loadTransactionsByDriverToMap(selectedDriverId.value!);
    }
  }

  Future<void> claimTransaction({required DbTransaction tx, String? comment}) async {
    // Partial update: only set pickedUp/comment/updatedAt
    await (db.update(db.transactions)..where((t) => t.id.equals(tx.id))).write(
      TransactionsCompanion(
        pickedUp: const drift.Value(true),
        comment: (comment == null || comment.trim().isEmpty)
            ? const drift.Value.absent()
            : drift.Value(comment.trim()),
        updatedAt: drift.Value(DateTime.now()),
      ),
    );
    // Record this claim event into report_transactions
    await db.insertReportTransaction(
      driverId: tx.driverId,
      transactionId: tx.id,
    );
    await loadTransactionsByDriverToMap(tx.driverId);
  }
}

